{"version":3,"sources":["../src/cli.ts","../src/githubPartialSubtree.ts"],"sourcesContent":["#!/usr/bin/env node\r\n/* eslint-disable no-console */\r\nimport { Command } from \"commander\";\r\nimport ora from \"ora\";\r\nimport chalk from \"chalk\";\r\nimport path from \"node:path\";\r\nimport os from \"node:os\";\r\nimport fs from \"node:fs/promises\";\r\nimport { spawn } from \"node:child_process\";\r\nimport { downloadSampleViaGitHubSubtree } from \"./githubPartialSubtree\";\r\nimport type { CliOptions, Mode, Method } from \"./cliOptions\";\r\n\r\n\r\nconst DEFAULT_OWNER = \"pnp\";\r\nconst DEFAULT_REPO = \"sp-dev-fx-webparts\";\r\nconst DEFAULT_REF = \"main\";\r\n\r\nfunction normalizeSampleArg(sample: string): string {\r\n    // Allow either \"react-my-sample\" OR \"samples/react-my-sample\"\r\n    const s = sample.replaceAll(\"\\\\\", \"/\").trim();\r\n    if (s.startsWith(\"samples/\")) return s.slice(\"samples/\".length);\r\n    return s;\r\n}\r\n\r\nasync function pathExists(p: string): Promise<boolean> {\r\n    try {\r\n        await fs.access(p);\r\n        return true;\r\n    } catch {\r\n        return false;\r\n    }\r\n}\r\n\r\nasync function isDirNonEmpty(p: string): Promise<boolean> {\r\n    try {\r\n        const entries = await fs.readdir(p);\r\n        return entries.length > 0;\r\n    } catch {\r\n        return false;\r\n    }\r\n}\r\n\r\ntype RunResult = { stdout: string; stderr: string };\r\n\r\nasync function run(\r\n    cmd: string,\r\n    args: string[],\r\n    opts: { cwd?: string; verbose?: boolean } = {}\r\n): Promise<RunResult> {\r\n    return new Promise((resolve, reject) => {\r\n        const child = spawn(cmd, args, {\r\n            cwd: opts.cwd,\r\n            shell: false,\r\n            windowsHide: true,\r\n            stdio: [\"ignore\", \"pipe\", \"pipe\"]\r\n        });\r\n\r\n        let stdout = \"\";\r\n        let stderr = \"\";\r\n\r\n        child.stdout.on(\"data\", (d) => {\r\n            const s = d.toString();\r\n            stdout += s;\r\n            if (opts.verbose) process.stdout.write(s);\r\n        });\r\n\r\n        child.stderr.on(\"data\", (d) => {\r\n            const s = d.toString();\r\n            stderr += s;\r\n            if (opts.verbose) process.stderr.write(s);\r\n        });\r\n\r\n        child.on(\"error\", (err) => reject(err));\r\n\r\n        child.on(\"close\", (code) => {\r\n            if (code === 0) resolve({ stdout, stderr });\r\n            else reject(new Error(`${cmd} ${args.join(\" \")} failed (exit ${code}).\\n${stderr || stdout}`));\r\n        });\r\n    });\r\n}\r\n\r\nfunction parseGitVersion(output: string): { major: number; minor: number; patch: number } | null {\r\n    const m = output.match(/git version (\\d+)\\.(\\d+)\\.(\\d+)/i);\r\n    if (!m) return null;\r\n    return { major: Number(m[1]), minor: Number(m[2]), patch: Number(m[3]) };\r\n}\r\n\r\nfunction versionGte(\r\n    v: { major: number; minor: number; patch: number },\r\n    min: { major: number; minor: number; patch: number }\r\n): boolean {\r\n    if (v.major !== min.major) return v.major > min.major;\r\n    if (v.minor !== min.minor) return v.minor > min.minor;\r\n    return v.patch >= min.patch;\r\n}\r\n\r\nasync function ensureGit(verbose?: boolean): Promise<void> {\r\n    let res: RunResult;\r\n    try {\r\n        res = await run(\"git\", [\"--version\"], { verbose });\r\n    } catch {\r\n        throw new Error(\r\n            \"Git was not found on PATH. Install Git for Windows (or your platform) and try again.\"\r\n        );\r\n    }\r\n\r\n    const v = parseGitVersion(res.stdout.trim());\r\n    if (!v) return;\r\n\r\n    // sparse-checkout cone mode: Git >= 2.25\r\n    const min = { major: 2, minor: 25, patch: 0 };\r\n    if (!versionGte(v, min)) {\r\n        throw new Error(\r\n            `Git ${v.major}.${v.minor}.${v.patch} is too old. Please upgrade to >= 2.25 for sparse-checkout cone mode.`\r\n        );\r\n    }\r\n}\r\n\r\nasync function isGitAvailable(verbose?: boolean): Promise<boolean> {\r\n    try {\r\n        await run(\"git\", [\"--version\"], { verbose });\r\n        return true;\r\n    } catch {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction assertMethod(m: string | undefined): Method {\r\n    if (!m) return \"auto\";\r\n    if (m === \"auto\" || m === \"git\" || m === \"api\") return m;\r\n    throw new Error(`Invalid --method \"${m}\". Use \"auto\", \"git\", or \"api\".`);\r\n}\r\n\r\nasync function copyDir(src: string, dest: string): Promise<void> {\r\n    await fs.mkdir(dest, { recursive: true });\r\n    // Node 18+ supports fs.cp\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    const fsp: any = fs;\r\n    if (typeof fsp.cp === \"function\") {\r\n        await fsp.cp(src, dest, { recursive: true });\r\n        return;\r\n    }\r\n\r\n    const entries = await fs.readdir(src, { withFileTypes: true });\r\n    for (const e of entries) {\r\n        const s = path.join(src, e.name);\r\n        const d = path.join(dest, e.name);\r\n        if (e.isDirectory()) await copyDir(s, d);\r\n        else await fs.copyFile(s, d);\r\n    }\r\n}\r\n\r\n/**\r\n * Perform a sparse+partial clone and checkout of the requested ref, keeping only `samples/<sampleFolder>` in the working tree.\r\n *\r\n * If `repoDir` is temp: you can copy the sample out after.\r\n * If `repoDir` is final destination: leave it there for contributor workflow.\r\n */\r\nasync function sparseCloneInto(args: {\r\n    owner: string;\r\n    repo: string;\r\n    ref: string;\r\n    sampleFolder: string;\r\n    repoDir: string;\r\n    verbose?: boolean;\r\n    spinner?: ReturnType<typeof ora>;\r\n}): Promise<void> {\r\n    const { owner, repo, ref, sampleFolder, repoDir, verbose, spinner } = args;\r\n\r\n    const repoUrl = `https://github.com/${owner}/${repo}.git`;\r\n    const sparsePath = `samples/${sampleFolder}`.replaceAll(\"\\\\\", \"/\");\r\n\r\n    spinner && (spinner.text = `Cloning (partial) ${owner}/${repo}…`);\r\n    await run(\r\n        \"git\",\r\n        [\"clone\", \"--depth=1\", \"--filter=blob:none\", \"--no-checkout\", repoUrl, repoDir],\r\n        { verbose }\r\n    );\r\n\r\n    spinner && (spinner.text = `Enabling sparse checkout…`);\r\n    await run(\"git\", [\"-C\", repoDir, \"sparse-checkout\", \"init\", \"--cone\"], { verbose });\r\n\r\n    spinner && (spinner.text = `Selecting ${sparsePath}…`);\r\n    await run(\"git\", [\"-C\", repoDir, \"sparse-checkout\", \"set\", sparsePath], { verbose });\r\n\r\n    spinner && (spinner.text = `Fetching ref ${ref}…`);\r\n    await run(\"git\", [\"-C\", repoDir, \"fetch\", \"--depth=1\", \"--filter=blob:none\", \"origin\", ref], {\r\n        verbose\r\n    });\r\n\r\n    spinner && (spinner.text = `Checking out ${ref}…`);\r\n    await run(\"git\", [\"-C\", repoDir, \"checkout\", \"--detach\", \"FETCH_HEAD\"], { verbose });\r\n\r\n    const srcSampleDir = path.join(repoDir, \"samples\", sampleFolder);\r\n    if (!(await pathExists(srcSampleDir)) || !(await isDirNonEmpty(srcSampleDir))) {\r\n        throw new Error(`Sample not found or empty: ${owner}/${repo}@${ref} → samples/${sampleFolder}`);\r\n    }\r\n}\r\n\r\nasync function fetchSampleViaSparseGitExtract(args: {\r\n    owner: string;\r\n    repo: string;\r\n    ref: string;\r\n    sampleFolder: string; // e.g. \"react-hello-world\"\r\n    destDir: string; // final output directory (sample root)\r\n    verbose?: boolean;\r\n    spinner?: ReturnType<typeof ora>;\r\n}): Promise<void> {\r\n    const { owner, repo, ref, sampleFolder, destDir, verbose, spinner } = args;\r\n\r\n    const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), \"spfx-sample-\"));\r\n    const tmpRepoDir = path.join(tmpRoot, \"repo\");\r\n\r\n    try {\r\n        await sparseCloneInto({ owner, repo, ref, sampleFolder, repoDir: tmpRepoDir, verbose, spinner });\r\n\r\n        const srcSampleDir = path.join(tmpRepoDir, \"samples\", sampleFolder);\r\n\r\n        spinner && (spinner.text = `Copying sample to ${destDir}…`);\r\n        await copyDir(srcSampleDir, destDir);\r\n    } finally {\r\n        await fs.rm(tmpRoot, { recursive: true, force: true }).catch(() => undefined);\r\n    }\r\n}\r\n\r\nfunction assertMode(m: string | undefined): Mode {\r\n    if (!m) return \"extract\";\r\n    if (m === \"extract\" || m === \"repo\") return m;\r\n    throw new Error(`Invalid --mode \"${m}\". Use \"extract\" or \"repo\".`);\r\n}\r\n\r\nconst program = new Command();\r\n\r\nprogram\r\n    .name(\"spfx-sample\")\r\n    .description(\"Fetch a single sample folder from a large GitHub repo using git sparse-checkout (no full clone).\")\r\n    .version(\"0.3.0\");\r\n\r\nprogram\r\n        .command(\"get\")\r\n        .argument(\"<sample>\", \"Sample folder name, e.g. react-hello-world OR samples/react-hello-world\")\r\n        .option(\"--owner <owner>\", \"GitHub org/user\", DEFAULT_OWNER)\r\n        .option(\"--repo <repo>\", \"GitHub repository name\", DEFAULT_REPO)\r\n        .option(\"--ref <ref>\", \"Git ref (branch, tag, or commit SHA)\", DEFAULT_REF)\r\n        .option(\"--dest <dest>\", \"Destination folder (default varies by --mode)\")\r\n        .option(\"--mode <mode>\", 'Mode: \"extract\" (copy sample out) or \"repo\" (leave sparse repo)', \"extract\")\r\n        .option(\"--method <method>\", 'Method: \"auto\" (git if available, else api), \"git\", or \"api\"', \"auto\")\r\n        .option(\"--force\", \"Overwrite destination if it exists\", false)\r\n        .option(\"--verbose\", \"Print git output\", false)\r\n\r\n    .action(async (sample: string, options: CliOptions) => {\r\n        const sampleFolder = normalizeSampleArg(sample);\r\n        const ref = options.ref || DEFAULT_REF;\r\n        const repo = options.repo || DEFAULT_REPO;\r\n        const owner = options.owner || DEFAULT_OWNER;\r\n        const verbose = !!options.verbose;\r\n\r\n        let mode: Mode;\r\n        try {\r\n            mode = assertMode(options.mode);\r\n        } catch (e) {\r\n            console.error(chalk.red((e as Error).message));\r\n            process.exitCode = 1;\r\n            return;\r\n        }\r\n\r\n        let method: Method;\r\n        try {\r\n            method = assertMethod(options.method);\r\n        } catch (e) {\r\n            console.error(chalk.red((e as Error).message));\r\n            process.exitCode = 1;\r\n            return;\r\n        }\r\n\r\n        // Default dest differs by mode:\r\n        // - extract: ./<sampleFolder>\r\n        // - repo:    ./<repo>-<sampleFolder>\r\n        const defaultDest =\r\n            mode === \"extract\" ? `./${sampleFolder}` : `./${repo}-${sampleFolder}`.replaceAll(\"/\", \"-\");\r\n\r\n        const destDir = path.resolve(options.dest ?? defaultDest);\r\n\r\n        // Decide method (auto => git if available, else api)\r\n        const gitAvailable = await isGitAvailable(verbose);\r\n        const chosen: Method = method === \"auto\" ? (gitAvailable ? \"git\" : \"api\") : method;\r\n\r\n        // If using git, validate git version/features\r\n        if (chosen === \"git\") {\r\n            try {\r\n                await ensureGit(verbose);\r\n            } catch (e) {\r\n                console.error(chalk.red((e as Error).message));\r\n                process.exitCode = 1;\r\n                return;\r\n            }\r\n        }\r\n\r\n        // API method can only do \"extract\" (no .git working repo)\r\n        if (chosen === \"api\" && mode === \"repo\") {\r\n            console.error(chalk.red(`--mode repo requires --method git (API method cannot create a git working repo).`));\r\n            process.exitCode = 1;\r\n            return;\r\n        }\r\n\r\n        // Handle destination\r\n        if (await pathExists(destDir)) {\r\n            if (!options.force) {\r\n                const nonEmpty = await isDirNonEmpty(destDir);\r\n                if (nonEmpty) {\r\n                    console.error(\r\n                        chalk.red(`Destination exists and is not empty: ${destDir}\\n`) +\r\n                        chalk.yellow(`Use --force to overwrite (or choose --dest).`)\r\n                    );\r\n                    process.exitCode = 1;\r\n                    return;\r\n                }\r\n            } else {\r\n                await fs.rm(destDir, { recursive: true, force: true });\r\n            }\r\n        }\r\n\r\n        const spinner = ora(`Getting sample ${sampleFolder} from ${owner}/${repo}@${ref}…`).start();\r\n\r\n        try {\r\n            if (chosen === \"api\") {\r\n                // Tokenless API method: download only that sample folder via subtree tree-walk + raw URLs\r\n                await fs.mkdir(destDir, { recursive: true });\r\n\r\n                await downloadSampleViaGitHubSubtree({\r\n                    owner,\r\n                    repo,\r\n                    ref,\r\n                    sampleFolder,\r\n                    destDir,\r\n                    concurrency: 8,\r\n                    onProgress: (done, total, filePath) => {\r\n                        spinner.text = `Downloading (${done}/${total})… ${filePath}`;\r\n                    }\r\n                });\r\n\r\n                spinner.succeed(\r\n                    `Done! Downloaded ${chalk.cyan(`samples/${sampleFolder}`)} into ${chalk.green(destDir)}`\r\n                );\r\n\r\n                console.log();\r\n                console.log(chalk.green(\"Next steps:\"));\r\n                console.log(chalk.yellow(`  cd \"${destDir}\"`));\r\n                console.log(chalk.yellow(\"  npm i\"));\r\n                console.log(chalk.yellow(\"  npm run build\"));\r\n                console.log(chalk.yellow(\"  npm run serve\"));\r\n                return;\r\n            }\r\n\r\n            // chosen === \"git\"\r\n            if (mode === \"extract\") {\r\n                await fetchSampleViaSparseGitExtract({\r\n                    owner,\r\n                    repo,\r\n                    ref,\r\n                    sampleFolder,\r\n                    destDir,\r\n                    verbose,\r\n                    spinner\r\n                });\r\n\r\n                spinner.succeed(\r\n                    `Done! Extracted ${chalk.cyan(`samples/${sampleFolder}`)} into ${chalk.green(destDir)}`\r\n                );\r\n\r\n                console.log();\r\n                console.log(chalk.green(\"Next steps:\"));\r\n                console.log(chalk.yellow(`  cd \"${destDir}\"`));\r\n                console.log(chalk.yellow(\"  npm i\"));\r\n                console.log(chalk.yellow(\"  npm run build\"));\r\n                console.log(chalk.yellow(\"  npm run serve\"));\r\n            } else {\r\n                // repo mode: sparse clone directly into destDir and keep .git there\r\n                await fs.mkdir(destDir, { recursive: true });\r\n\r\n                await sparseCloneInto({\r\n                    owner,\r\n                    repo,\r\n                    ref,\r\n                    sampleFolder,\r\n                    repoDir: destDir,\r\n                    verbose,\r\n                    spinner\r\n                });\r\n\r\n                const samplePath = path.join(destDir, \"samples\", sampleFolder);\r\n\r\n                spinner.succeed(\r\n                    `Done! Sparse repo ready at ${chalk.green(destDir)} (sample at ${chalk.cyan(samplePath)})`\r\n                );\r\n\r\n                console.log();\r\n                console.log(chalk.green(\"Next steps:\"));\r\n                console.log(chalk.yellow(`  cd \"${samplePath}\"`));\r\n                console.log(chalk.yellow(\"  npm i\"));\r\n                console.log(chalk.yellow(\"  npm run build\"));\r\n                console.log(chalk.yellow(\"  npm run serve\"));\r\n                console.log();\r\n                console.log(chalk.green(\"Contribute back:\"));\r\n                console.log(chalk.yellow(`  cd \"${destDir}\"`));\r\n                console.log(chalk.yellow(\"  git status\"));\r\n                console.log(chalk.yellow(\"  git checkout -b my-change\"));\r\n            }\r\n        } catch (err) {\r\n            spinner.fail((err as Error).message);\r\n            process.exitCode = 1;\r\n        }\r\n    });\r\n\r\nprogram.parse(process.argv);\r\n","import path from \"node:path\";\r\nimport fs from \"node:fs/promises\";\r\n\r\ntype TreeItem = { path: string; type: \"blob\" | \"tree\"; sha: string };\r\ntype TreeResponse = { tree: TreeItem[]; truncated?: boolean; message?: string };\r\n\r\nexport type DownloadSubtreeOptions = {\r\n    owner: string;\r\n    repo: string;\r\n    ref: string;                 // branch/tag/sha\r\n    sampleFolder: string;         // e.g. \"react-hello-world\"\r\n    destDir: string;              // where to write files\r\n    concurrency?: number;          // default 8\r\n    onProgress?: (done: number, total: number, filePath: string) => void;\r\n};\r\n\r\nfunction createSemaphore(max: number) {\r\n    let running = 0;\r\n    const queue: Array<() => void> = [];\r\n    const next = () => {\r\n        running--;\r\n        const fn = queue.shift();\r\n        if (fn) fn();\r\n    };\r\n    return async <T>(fn: () => Promise<T>): Promise<T> =>\r\n        new Promise<T>((resolve, reject) => {\r\n            const run = async () => {\r\n                running++;\r\n                try { resolve(await fn()); }\r\n                catch (e) { reject(e); }\r\n                finally { next(); }\r\n            };\r\n            if (running < max) run();\r\n            else queue.push(run);\r\n        });\r\n}\r\n\r\nasync function fetchJson<T>(url: string): Promise<T> {\r\n    const res = await fetch(url, { headers: { \"User-Agent\": \"@pnp/spfx-sample\" } });\r\n    const data = (await res.json()) as any;\r\n\r\n    if (!res.ok) {\r\n        // friendly rate-limit message\r\n        if (res.status === 403 && res.headers.get(\"X-RateLimit-Remaining\") === \"0\") {\r\n            throw new Error(\r\n                \"GitHub anonymous rate limit hit (60/hr per IP). Try again later, or install/use the git method.\"\r\n            );\r\n        }\r\n        throw new Error(`GitHub API error: ${data?.message ?? `${res.status} ${res.statusText}`}`);\r\n    }\r\n\r\n    return data as T;\r\n}\r\n\r\nasync function fetchTree(owner: string, repo: string, treeish: string, recursive = false): Promise<TreeResponse> {\r\n    const url = `https://api.github.com/repos/${owner}/${repo}/git/trees/${encodeURIComponent(treeish)}${recursive ? \"?recursive=1\" : \"\"}`;\r\n    return fetchJson<TreeResponse>(url);\r\n}\r\n\r\nasync function ensureDirForFile(filePath: string): Promise<void> {\r\n    await fs.mkdir(path.dirname(filePath), { recursive: true });\r\n}\r\n\r\nexport async function downloadSampleViaGitHubSubtree(opts: DownloadSubtreeOptions): Promise<void> {\r\n    const { owner, repo, ref, sampleFolder, destDir } = opts;\r\n    const concurrency = opts.concurrency ?? 8;\r\n\r\n    // 1) root tree\r\n    const root = await fetchTree(owner, repo, ref, false);\r\n    if (root.message) throw new Error(root.message);\r\n\r\n    const samplesTree = root.tree.find(t => t.type === \"tree\" && t.path === \"samples\");\r\n    if (!samplesTree) throw new Error(`Could not find /samples at ${owner}/${repo}@${ref}`);\r\n\r\n    // 2) /samples tree\r\n    const samples = await fetchTree(owner, repo, samplesTree.sha, false);\r\n    const sampleTree = samples.tree.find(t => t.type === \"tree\" && t.path === sampleFolder);\r\n    if (!sampleTree) throw new Error(`Sample folder not found: samples/${sampleFolder} at ${ref}`);\r\n\r\n    // 3) sample subtree (recursive)\r\n    const sample = await fetchTree(owner, repo, sampleTree.sha, true);\r\n    if (sample.truncated) {\r\n        // extremely unlikely for a single sample, but handle anyway\r\n        throw new Error(`Tree listing truncated for samples/${sampleFolder}. Use the git method.`);\r\n    }\r\n\r\n    const blobs = sample.tree.filter(t => t.type === \"blob\");\r\n    if (blobs.length === 0) throw new Error(`No files found in samples/${sampleFolder}`);\r\n\r\n    await fs.mkdir(destDir, { recursive: true });\r\n\r\n    const sem = createSemaphore(concurrency);\r\n    let done = 0;\r\n\r\n    await Promise.all(\r\n        blobs.map(b =>\r\n            sem(async () => {\r\n                const rel = b.path; // path relative to samples/<sampleFolder>\r\n                const fullRepoPath = `samples/${sampleFolder}/${rel}`;\r\n\r\n                const rawUrl = `https://raw.githubusercontent.com/${owner}/${repo}/${encodeURIComponent(ref)}/${fullRepoPath}`;\r\n                const res = await fetch(rawUrl);\r\n                if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText} for ${fullRepoPath}`);\r\n\r\n                const bytes = new Uint8Array(await res.arrayBuffer());\r\n                const outPath = path.join(destDir, rel);\r\n\r\n                await ensureDirForFile(outPath);\r\n                await fs.writeFile(outPath, bytes);\r\n\r\n                done++;\r\n                opts.onProgress?.(done, blobs.length, fullRepoPath);\r\n            })\r\n        )\r\n    );\r\n}\r\n"],"mappings":"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","names":["import_node_path","import_promises","run","fs","path","fs","path","os","chalk","ora"]}