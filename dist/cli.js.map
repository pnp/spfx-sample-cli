{"version":3,"sources":["../src/cli.ts","../src/githubPartialSubtree.ts","../src/detectVersionManagers.ts","../src/detectServeCommand.ts"],"sourcesContent":["#!/usr/bin/env node\r\n/* eslint-disable no-console */\r\nimport { Command } from \"commander\";\r\nimport ora from \"ora\";\r\nimport chalk from \"chalk\";\r\nimport path from \"node:path\";\r\nimport os from \"node:os\";\r\nimport fs from \"node:fs/promises\";\r\nimport { spawn } from \"node:child_process\";\r\nimport { randomUUID } from \"node:crypto\";\r\n\r\nimport { downloadSampleViaGitHubSubtree } from \"./githubPartialSubtree\";\r\nimport ProgressBar from \"progress\";\r\nimport detectVersionManagers from \"./detectVersionManagers\";\r\nimport detectServeCommand from \"./detectServeCommand\";\r\nimport type { CliOptions, Mode, Method } from \"./cliOptions\";\r\nimport https from \"node:https\";\r\n\r\n\r\nconst DEFAULT_OWNER = \"pnp\";\r\nconst DEFAULT_REPO = \"sp-dev-fx-webparts\";\r\nconst DEFAULT_REF = \"main\";\r\n\r\n// Global handlers to ensure process exits with non-zero code on unexpected errors\r\nprocess.on(\"unhandledRejection\", (reason) => {\r\n    console.error(\"Unhandled Promise rejection:\", reason);\r\n    process.exitCode = 1;\r\n});\r\n\r\nprocess.on(\"uncaughtException\", (err) => {\r\n    console.error(\"Uncaught exception:\", (err as Error).message || err);\r\n    process.exitCode = 1;\r\n    // give other handlers a chance then exit\r\n    setImmediate(() => process.exit(1));\r\n});\r\n\r\nfunction normalizeSampleArg(sample: string): string {\r\n    // Allow either \"react-my-sample\" OR \"samples/react-my-sample\"\r\n    const s = sample.replaceAll(\"\\\\\", \"/\").trim();\r\n    if (s.startsWith(\"samples/\")) return s.slice(\"samples/\".length);\r\n    return s;\r\n}\r\nexport { normalizeSampleArg };\r\n\r\nasync function pathExists(p: string): Promise<boolean> {\r\n    try {\r\n        await fs.access(p);\r\n        return true;\r\n    } catch {\r\n        return false;\r\n    }\r\n}\r\n\r\nasync function isDirNonEmpty(p: string): Promise<boolean> {\r\n    try {\r\n        const entries = await fs.readdir(p);\r\n        return entries.length > 0;\r\n    } catch {\r\n        return false;\r\n    }\r\n}\r\n\r\ntype RunResult = { stdout: string; stderr: string };\r\n\r\nasync function run(\r\n    cmd: string,\r\n    args: string[],\r\n    opts: { cwd?: string; verbose?: boolean; signal?: AbortSignal } = {}\r\n): Promise<RunResult> {\r\n    return new Promise((resolve, reject) => {\r\n        if (opts.verbose) console.error(`[debug] spawn: ${cmd} ${args.join(\" \")} cwd=${opts.cwd ?? process.cwd()}`);\r\n        const child = spawn(cmd, args, {\r\n            cwd: opts.cwd,\r\n            shell: false,\r\n            windowsHide: true,\r\n            stdio: [\"ignore\", \"pipe\", \"pipe\"]\r\n        });\r\n\r\n        // If an AbortSignal is provided, try to kill the child when aborted\r\n        if (opts.signal) {\r\n            if (opts.signal.aborted) {\r\n                child.kill();\r\n            } else {\r\n                const onAbort = () => {\r\n                    try { child.kill(); } catch {}\r\n                };\r\n                opts.signal.addEventListener(\"abort\", onAbort, { once: true });\r\n            }\r\n        }\r\n\r\n        let stdout = \"\";\r\n        let stderr = \"\";\r\n\r\n        child.stdout.on(\"data\", (d) => {\r\n            const s = d.toString();\r\n            stdout += s;\r\n            if (opts.verbose) process.stdout.write(s);\r\n        });\r\n\r\n        child.stderr.on(\"data\", (d) => {\r\n            const s = d.toString();\r\n            stderr += s;\r\n            if (opts.verbose) process.stderr.write(s);\r\n        });\r\n\r\n        child.on(\"error\", (err) => reject(err));\r\n\r\n        child.on(\"close\", (code) => {\r\n            if (code === 0) resolve({ stdout, stderr });\r\n            else reject(new Error(`${cmd} ${args.join(\" \")} failed (exit ${code}).\\n${stderr || stdout}`));\r\n        });\r\n    });\r\n}\r\n\r\nfunction parseGitVersion(output: string): { major: number; minor: number; patch: number } | null {\r\n    const m = output.match(/git version (\\d+)\\.(\\d+)\\.(\\d+)/i);\r\n    if (!m) return null;\r\n    return { major: Number(m[1]), minor: Number(m[2]), patch: Number(m[3]) };\r\n}\r\nexport { parseGitVersion };\r\n\r\nfunction versionGte(\r\n    v: { major: number; minor: number; patch: number },\r\n    min: { major: number; minor: number; patch: number }\r\n): boolean {\r\n    if (v.major !== min.major) return v.major > min.major;\r\n    if (v.minor !== min.minor) return v.minor > min.minor;\r\n    return v.patch >= min.patch;\r\n}\r\nexport { versionGte };\r\n\r\nasync function ensureGit(verbose?: boolean): Promise<void> {\r\n    let res: RunResult;\r\n    try {\r\n        res = await run(\"git\", [\"--version\"], { verbose });\r\n    } catch {\r\n        throw new Error(\r\n            \"Git was not found on PATH. Install Git for Windows (or your platform) and try again.\"\r\n        );\r\n    }\r\n\r\n    const v = parseGitVersion(res.stdout.trim());\r\n    if (!v) return;\r\n\r\n    // sparse-checkout cone mode: Git >= 2.25\r\n    const min = { major: 2, minor: 25, patch: 0 };\r\n    if (!versionGte(v, min)) {\r\n        throw new Error(\r\n            `Git ${v.major}.${v.minor}.${v.patch} is too old. Please upgrade to >= 2.25 for sparse-checkout cone mode.`\r\n        );\r\n    }\r\n}\r\n\r\nasync function isGitAvailable(verbose?: boolean): Promise<boolean> {\r\n    try {\r\n        await run(\"git\", [\"--version\"], { verbose });\r\n        return true;\r\n    } catch {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction assertMethod(m: string | undefined): Method {\r\n    if (!m) return \"auto\";\r\n    if (m === \"auto\" || m === \"git\" || m === \"api\") return m;\r\n    throw new Error(`Invalid --method \"${m}\". Use \"auto\", \"git\", or \"api\".`);\r\n}\r\nexport { assertMethod };\r\n\r\nasync function copyDir(src: string, dest: string): Promise<void> {\r\n    await fs.mkdir(dest, { recursive: true });\r\n    // Node 18+ supports fs.cp\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    const fsp: any = fs;\r\n    if (typeof fsp.cp === \"function\") {\r\n        await fsp.cp(src, dest, { recursive: true });\r\n        return;\r\n    }\r\n\r\n    const entries = await fs.readdir(src, { withFileTypes: true });\r\n    for (const e of entries) {\r\n        const s = path.join(src, e.name);\r\n        const d = path.join(dest, e.name);\r\n        if (e.isDirectory()) await copyDir(s, d);\r\n        else await fs.copyFile(s, d);\r\n    }\r\n}\r\n\r\n/**\r\n * Perform a sparse+partial clone and checkout of the requested ref, keeping only `samples/<sampleFolder>` in the working tree.\r\n *\r\n * If `repoDir` is temp: you can copy the sample out after.\r\n * If `repoDir` is final destination: leave it there for contributor workflow.\r\n */\r\nasync function sparseCloneInto(args: {\r\n    owner: string;\r\n    repo: string;\r\n    ref: string;\r\n    sampleFolder: string;\r\n    repoDir: string;\r\n    verbose?: boolean;\r\n    spinner?: ReturnType<typeof ora>;\r\n    signal?: AbortSignal;\r\n}): Promise<void> {\r\n    const { owner, repo, ref, sampleFolder, repoDir, verbose, spinner } = args;\r\n\r\n    const repoUrl = `https://github.com/${owner}/${repo}.git`;\r\n    const sparsePath = `samples/${sampleFolder}`.replaceAll(\"\\\\\", \"/\");\r\n\r\n    spinner && (spinner.text = `Cloning (partial) ${owner}/${repo}â€¦`);\r\n    await run(\r\n        \"git\",\r\n        [\"clone\", \"--depth=1\", \"--filter=blob:none\", \"--no-checkout\", repoUrl, repoDir],\r\n        { verbose, signal: args.signal }\r\n    );\r\n\r\n    spinner && (spinner.text = `Enabling sparse checkoutâ€¦`);\r\n    await run(\"git\", [\"-C\", repoDir, \"sparse-checkout\", \"init\", \"--cone\"], { verbose, signal: args.signal });\r\n\r\n    spinner && (spinner.text = `Selecting ${sparsePath}â€¦`);\r\n    await run(\"git\", [\"-C\", repoDir, \"sparse-checkout\", \"set\", sparsePath], { verbose, signal: args.signal });\r\n\r\n    spinner && (spinner.text = `Switching to ${ref} branchâ€¦`);\r\n    await run(\"git\", [\"-C\", repoDir, \"fetch\", \"--depth=1\", \"--filter=blob:none\", \"origin\", ref], {\r\n        verbose,\r\n        signal: args.signal\r\n    });\r\n\r\n    spinner && (spinner.text = `Getting sample from ${ref} branchâ€¦`);\r\n    await run(\"git\", [\"-C\", repoDir, \"checkout\", \"--detach\", \"FETCH_HEAD\"], { verbose, signal: args.signal });\r\n\r\n    const srcSampleDir = path.join(repoDir, \"samples\", sampleFolder);\r\n    if (!(await pathExists(srcSampleDir)) || !(await isDirNonEmpty(srcSampleDir))) {\r\n        throw new Error(`Sample not found or empty: ${owner}/${repo}@${ref} â†’ samples/${sampleFolder}`);\r\n    }\r\n}\r\n\r\nasync function fetchSampleViaSparseGitExtract(args: {\r\n    owner: string;\r\n    repo: string;\r\n    ref: string;\r\n    sampleFolder: string; // e.g. \"react-hello-world\"\r\n    destDir: string; // final output directory (sample root)\r\n    verbose?: boolean;\r\n    spinner?: ReturnType<typeof ora>;\r\n    signal?: AbortSignal;\r\n}): Promise<void> {\r\n    const { owner, repo, ref, sampleFolder, destDir, verbose, spinner } = args;\r\n\r\n    const tmpRoot = await fs.mkdtemp(path.join(os.tmpdir(), \"spfx-sample-\"));\r\n    const tmpRepoDir = path.join(tmpRoot, \"repo\");\r\n\r\n    try {\r\n        await sparseCloneInto({ owner, repo, ref, sampleFolder, repoDir: tmpRepoDir, verbose, spinner, signal: args.signal });\r\n\r\n        const srcSampleDir = path.join(tmpRepoDir, \"samples\", sampleFolder);\r\n\r\n        spinner && (spinner.text = `Copying sample to ${destDir}â€¦`);\r\n        await copyDir(srcSampleDir, destDir);\r\n    } finally {\r\n        await fs.rm(tmpRoot, { recursive: true, force: true }).catch(() => undefined);\r\n    }\r\n}\r\n\r\nasync function readNvmrc(root: string): Promise<string | null> {\r\n    const p = path.join(root, '.nvmrc');\r\n    try {\r\n        const txt = await fs.readFile(p, 'utf8');\r\n        const v = txt.split(/\\r?\\n/)[0].trim();\r\n        return v || null;\r\n    } catch {\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction parseNodeVersion(v: string | null): { major: number; minor: number; patch: number } | null {\r\n    if (!v) return null;\r\n    // Allow forms like: 14, 14.17, 14.17.0, v14.17.0\r\n    const s = v.trim().replace(/^v/, '');\r\n    const parts = s.split('.').map((p) => Number(p || 0));\r\n    if (parts.some((n) => Number.isNaN(n))) return null;\r\n    return { major: parts[0] || 0, minor: parts[1] || 0, patch: parts[2] || 0 };\r\n}\r\n\r\nfunction nodeVersionGte(a: { major: number; minor: number; patch: number }, b: { major: number; minor: number; patch: number }): boolean {\r\n    if (a.major !== b.major) return a.major > b.major;\r\n    if (a.minor !== b.minor) return a.minor > b.minor;\r\n    return a.patch >= b.patch;\r\n}\r\n\r\nfunction getCurrentNodeVersion(): { major: number; minor: number; patch: number } | null {\r\n    const v = process.version.replace(/^v/, '');\r\n    const parts = v.split('.').map((p) => Number(p));\r\n    if (parts.some((n) => Number.isNaN(n))) return null;\r\n    return { major: parts[0], minor: parts[1], patch: parts[2] };\r\n}\r\n\r\nasync function maybePrintNvmrcAdvice(sampleRoot: string): Promise<void> {\r\n    const nvmrc = await readNvmrc(sampleRoot);\r\n    const debug = typeof process.env.SPFX_SAMPLE_DEBUG !== 'undefined';\r\n    const dbg = (msg: string) => { if (debug) console.error('[spfx-debug]', msg); };\r\n    if (debug) console.error('[spfx-debug] maybePrintNvmrcAdvice invoked for: ' + sampleRoot);\r\n\r\n    // If .nvmrc is present, preserve existing behavior\r\n    if (nvmrc) {\r\n        dbg(`.nvmrc found: ${nvmrc}`);\r\n        const required = parseNodeVersion(nvmrc);\r\n        const current = getCurrentNodeVersion();\r\n\r\n        if (!required || !current) return;\r\n\r\n        // Show advice when the major versions differ (e.g., current is v22, required v10)\r\n        if (current.major !== required.major) {\r\n            console.log();\r\n            console.log(chalk.yellow(`This sample suggests Node ${nvmrc} (from .nvmrc).`));\r\n            console.log(chalk.yellow(`Your current Node is ${process.version}.`));\r\n\r\n            // Helpful hint: detect common node version managers\r\n            try {\r\n                const dm = await detectVersionManagers();\r\n                const choices: string[] = [];\r\n                if (dm.nvmPosix) choices.push(`${chalk.yellow(\"nvm\")} ${chalk.white(\"use\")} ${chalk.white(nvmrc)}`);\r\n                if (dm.nvmWindows) choices.push(`${chalk.yellow(\"nvm\")} ${chalk.white(\"use\")} ${chalk.white(nvmrc)}`);\r\n                if (dm.nvs) choices.push(`${chalk.yellow(\"nvs\")} ${chalk.white(\"use\")} ${chalk.white(nvmrc)}`);\r\n\r\n                if (choices.length === 0) {\r\n                    console.log(chalk.yellow(\"Consider installing a Node version manager such as nvm, nvm-windows, or nvs.\"));\r\n                }\r\n                if (choices.length > 0) {\r\n                    console.log();\r\n                    console.log(chalk.yellow(\"You can switch to the required Node version with:\"));\r\n                }\r\n                if (choices.length === 1) {\r\n                    console.log(`  ${choices[0]}`);\r\n                } else if (choices.length > 1) {\r\n                    console.log(`  ${choices[0]}`);\r\n                    for (let i = 1; i < choices.length; i++) {\r\n                        console.log(chalk.yellow(\"or:\"));\r\n                        console.log(`  ${choices[i]}`);\r\n                    }\r\n                }\r\n\r\n                console.log();\r\n                console.log(chalk.yellow(\"Then:\"));\r\n            } catch {\r\n                // ignore detection failures\r\n            }\r\n\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    // Fallback: if no .nvmrc, try to infer SPFx version from package.json and consult SPFx matrix\r\n    try {\r\n        const pkg = await readJsonIfExists<any>(path.join(sampleRoot, \"package.json\"));\r\n        if (!pkg) { dbg('no package.json found'); return; }\r\n\r\n        // Look for @microsoft/sp-* dependencies to infer SPFx version\r\n        const deps = { ...(pkg.dependencies || {}), ...(pkg.devDependencies || {}) };\r\n        dbg(`found ${Object.keys(deps).length} deps`);\r\n        const spfxPkgs = Object.keys(deps).filter((k) => k.startsWith(\"@microsoft/sp-\"));\r\n        const versions: Array<{ pkg: string; ver: string }> = [];\r\n        for (const p of spfxPkgs) {\r\n            const raw = deps[p];\r\n            if (typeof raw === \"string\") {\r\n                versions.push({ pkg: p, ver: raw });\r\n            }\r\n        }\r\n        if (versions.length === 0) { dbg('no @microsoft/sp- packages found'); return; }\r\n\r\n        function parseSemverLoose(s: string | undefined): { major: number; minor: number; patch: number } | null {\r\n            if (!s) return null;\r\n            const cleaned = s.trim().replace(/^[^0-9]*/, '').replace(/[^0-9.].*$/, '');\r\n            const parts = cleaned.split('.').map((p) => Number(p || 0));\r\n            if (parts.some((n) => Number.isNaN(n))) return null;\r\n            return { major: parts[0] || 0, minor: parts[1] || 0, patch: parts[2] || 0 };\r\n        }\r\n\r\n        // Pick the highest semver among detected spfx package versions.\r\n        // Prefer specific package keys when available because some samples include a broad \"office-ui-fabric-react-bundle\"\r\n        // which may not reflect the core SPFx runtime version as accurately as `sp-webpart-base` or `sp-core-library`.\r\n        const preferredOrder = [\"@microsoft/sp-webpart-base\", \"@microsoft/sp-core-library\", \"@microsoft/sp-module-interfaces\"];\r\n\r\n        function pickHighest(list) {\r\n            let b = null;\r\n            for (const v of list) {\r\n                const sem = parseSemverLoose(v.ver);\r\n                if (!sem) continue;\r\n                if (!b) b = { pkg: v.pkg, ver: v.ver, sem };\r\n                else {\r\n                    if (sem.major > (b.sem!.major) || (sem.major === b.sem!.major && (sem.minor > b.sem!.minor || (sem.minor === b.sem!.minor && sem.patch > b.sem!.patch)))) {\r\n                        b = { pkg: v.pkg, ver: v.ver, sem };\r\n                    }\r\n                }\r\n            }\r\n            return b;\r\n        }\r\n\r\n        // Try preferred packages first\r\n        let best: { pkg: string; ver: string; sem?: { major: number; minor: number; patch: number } } | null = null;\r\n        const preferredCandidates = versions.filter((v) => preferredOrder.includes(v.pkg));\r\n        if (preferredCandidates.length > 0) {\r\n            best = pickHighest(preferredCandidates);\r\n        }\r\n        // Fallback to any detected spfx package\r\n        if (!best) {\r\n            best = pickHighest(versions);\r\n        }\r\n        if (!best || !best.sem) { dbg('could not parse semver from spfx packages'); return; }\r\n\r\n        // Fetch SPFx matrix JSON from repo\r\n        const matrixUrl = 'https://github.com/SharePoint/sp-dev-docs/raw/main/assets/spfx/spfx-matrix.json';\r\n        const matrix = await fetchJsonUrl(matrixUrl);\r\n        if (!matrix) { dbg('could not fetch or parse spfx matrix'); return; }\r\n\r\n        // Normalize matrix entries to array of {spfx: semverStr, node: recommended}\r\n        const entries: Array<{ spfx: string; node?: string }> = [];\r\n        if (Array.isArray(matrix)) {\r\n            for (const e of matrix) {\r\n                if (!e) continue;\r\n                const sp = e.spfx || e.spfxVersion || e.version;\r\n                const node = e.node || e.nodeVersion || (Array.isArray(e.nodeVersions) ? e.nodeVersions[0] : undefined) || e.recommendedNode;\r\n                if (sp) entries.push({ spfx: String(sp), node: node ? String(node) : undefined });\r\n            }\r\n        } else if (typeof matrix === 'object') {\r\n            for (const k of Object.keys(matrix)) {\r\n                const val = (matrix as any)[k];\r\n                if (val && typeof val === 'object') {\r\n                    const node = val.node || val.nodeVersion || (Array.isArray(val.nodeVersions) ? val.nodeVersions[0] : undefined) || val.recommendedNode;\r\n                    entries.push({ spfx: k, node: node ? String(node) : undefined });\r\n                } else if (typeof val === 'string') {\r\n                    entries.push({ spfx: k, node: val });\r\n                }\r\n            }\r\n        }\r\n        if (entries.length === 0) { dbg('no entries parsed from matrix'); return; }\r\n\r\n        function semKey(s: string): { major: number; minor: number; patch: number } | null {\r\n            const m = s.replace(/^[^0-9]*/, '').match(/(\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))?/);\r\n            if (!m) return null;\r\n            return { major: Number(m[1]), minor: Number(m[2] || 0), patch: Number(m[3] || 0) };\r\n        }\r\n\r\n        // Find closest entry (prefer exact match, then closest by major/minor)\r\n        let bestEntry: { spfx: string; node?: string } | null = null;\r\n        let bestScore = Number.MAX_SAFE_INTEGER;\r\n        for (const e of entries) {\r\n            const sem = semKey(e.spfx);\r\n            if (!sem) continue;\r\n            if (sem.major === best.sem!.major && sem.minor === best.sem!.minor && sem.patch === best.sem!.patch) {\r\n                bestEntry = e;\r\n                break;\r\n            }\r\n            const score = Math.abs(sem.major - best.sem!.major) * 10000 + Math.abs(sem.minor - best.sem!.minor) * 100 + Math.abs(sem.patch - best.sem!.patch);\r\n            if (score < bestScore) {\r\n                bestScore = score;\r\n                bestEntry = e;\r\n            }\r\n        }\r\n\r\n        if (bestEntry && bestEntry.node) {\r\n            console.log();\r\n            console.log(chalk.yellow(`âš ï¸ This sample appears to use SharePoint Framework ${best.sem!.major}.${best.sem!.minor}.${best.sem!.patch} (detected from ${best.pkg}).`));\r\n            console.log(chalk.yellow(`A suitable Node version is ${bestEntry.node}. See http://aka.ms/spfx-matrix for details.`));\r\n\r\n            // If current Node differs (major), suggest switching via version managers when available\r\n            try {\r\n                const current = getCurrentNodeVersion();\r\n                const recMatch = String(bestEntry.node).match(/v?(\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))?/);\r\n                const recSem = recMatch ? { major: Number(recMatch[1]), minor: Number(recMatch[2] || 0), patch: Number(recMatch[3] || 0) } : null;\r\n                if (current && recSem && current.major !== recSem.major) {\r\n                    console.log();\r\n                    console.log(chalk.yellow(`Your current Node is ${process.version}.`));\r\n\r\n                    const dm = await detectVersionManagers();\r\n                    const choices: string[] = [];\r\n                    const useVer = recMatch ? `${recSem.major}${recSem.minor ? `.${recSem.minor}` : ''}${recSem.patch ? `.${recSem.patch}` : ''}` : String(bestEntry.node);\r\n                    if (dm.nvmPosix) choices.push(`${chalk.yellow(\"nvm\")} ${chalk.white(\"use\")} ${chalk.white(useVer)}`);\r\n                    if (dm.nvmWindows) choices.push(`${chalk.yellow(\"nvm\")} ${chalk.white(\"use\")} ${chalk.white(useVer)}`);\r\n                    if (dm.nvs) choices.push(`${chalk.yellow(\"nvs\")} ${chalk.white(\"use\")} ${chalk.white(useVer)}`);\r\n\r\n                    if (choices.length === 0) {\r\n                        console.log(chalk.yellow(\"Consider installing a Node version manager such as nvm, nvm-windows, or nvs.\"));\r\n                    } else {\r\n                        console.log();\r\n                        console.log(chalk.yellow(\"You can switch to the recommended Node version with:\"));\r\n                        for (let i = 0; i < choices.length; i++) {\r\n                            if (i > 0) console.log(chalk.yellow(\"or:\"));\r\n                            console.log(`  ${choices[i]}`);\r\n                        }\r\n                        console.log();\r\n                        console.log(chalk.yellow(\"Then:\"));\r\n                    }\r\n                }\r\n            } catch {\r\n                // ignore detection failures\r\n            }\r\n        }\r\n\r\n    } catch {\r\n        // silently ignore any failures here\r\n    }\r\n\r\n}\r\n\r\nexport { maybePrintNvmrcAdvice, fetchJsonUrl, getSpfxMatrix };\r\n\r\nasync function fetchJsonUrl(url: string): Promise<any | null> {\r\n    const maxRedirects = 5;\r\n    return new Promise((resolve) => {\r\n        let redirects = 0;\r\n        const doGet = (u: string) => {\r\n            try {\r\n                const req = https.get(u, (res) => {\r\n                    // Follow redirects\r\n                    if (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\r\n                        if (redirects++ < maxRedirects) {\r\n                            const loc = res.headers.location!.startsWith('http') ? res.headers.location! : new URL(res.headers.location!, u).toString();\r\n                            res.resume();\r\n                            doGet(loc);\r\n                            return;\r\n                        }\r\n                        resolve(null);\r\n                        res.resume();\r\n                        return;\r\n                    }\r\n\r\n                    if (res.statusCode && (res.statusCode < 200 || res.statusCode >= 300)) {\r\n                        resolve(null);\r\n                        res.resume();\r\n                        return;\r\n                    }\r\n\r\n                    const chunks: Buffer[] = [];\r\n                    res.on('data', (d) => chunks.push(Buffer.isBuffer(d) ? d : Buffer.from(String(d))));\r\n                    res.on('end', () => {\r\n                        try {\r\n                            const txt = Buffer.concat(chunks).toString('utf8');\r\n                            const j = JSON.parse(txt);\r\n                            resolve(j);\r\n                        } catch {\r\n                            resolve(null);\r\n                        }\r\n                    });\r\n                });\r\n                req.on('error', () => resolve(null));\r\n                req.setTimeout(5000, () => { req.destroy(); resolve(null); });\r\n            } catch {\r\n                resolve(null);\r\n            }\r\n        };\r\n\r\n        doGet(url);\r\n    });\r\n}\r\n\r\nasync function getSpfxMatrix(): Promise<any | null> {\r\n    const cacheDir = path.join(os.tmpdir(), 'spfx-sample-cli');\r\n    const cacheFile = path.join(cacheDir, 'spfx-matrix.json');\r\n    const ttlMs = 1000 * 60 * 60 * 24; // 24 hours\r\n\r\n    try {\r\n        // Try cached version first\r\n        const st = await fs.stat(cacheFile).catch(() => null);\r\n        if (st && (Date.now() - st.mtimeMs) < ttlMs) {\r\n            const txt = await fs.readFile(cacheFile, 'utf8').catch(() => null);\r\n            if (txt) return JSON.parse(txt);\r\n        }\r\n    } catch {\r\n        // ignore cache read errors\r\n    }\r\n\r\n    // Fetch from upstream and cache\r\n    const url = 'https://raw.githubusercontent.com/SharePoint/sp-dev-docs/main/assets/spfx/spfx-matrix.json';\r\n    const j = await fetchJsonUrl(url);\r\n    if (j) {\r\n        try {\r\n            await fs.mkdir(cacheDir, { recursive: true });\r\n            await fs.writeFile(cacheFile, JSON.stringify(j, null, 2), 'utf8');\r\n        } catch {\r\n            // ignore cache write failures\r\n        }\r\n    }\r\n    return j;\r\n}\r\n\r\ntype FinalizeArgs = {\r\n    spinner?: ReturnType<typeof ora>;\r\n    successMessage: string;\r\n    projectPath: string; // directory where to run npm i / build / serve\r\n    repoRoot?: string; // when repo mode: top-level repo dir to show contribute back\r\n};\r\n\r\nasync function finalizeExtraction(opts: FinalizeArgs): Promise<void> {\r\n    const { spinner, successMessage, projectPath, repoRoot } = opts;\r\n\r\n    spinner && spinner.succeed(successMessage);\r\n\r\n    // Place for additional post-extract logic (user requested hook)\r\n    // e.g. customize project files, run transforms, etc.\r\n\r\n    console.log();\r\n    console.log(chalk.green(\"Next steps:\"));\r\n    console.log(`  ${chalk.yellow(\"cd\")} ${chalk.blue(`\"${projectPath}\"`)} `);\r\n    if (typeof process.env.SPFX_SAMPLE_DEBUG !== 'undefined') console.error('[spfx-debug] calling maybePrintNvmrcAdvice for: ' + projectPath);\r\n    await maybePrintNvmrcAdvice(projectPath);\r\n    console.log(chalk.white(`  ${chalk.yellow(\"npm\")} ${chalk.white(\"i\")}`));\r\n    console.log(chalk.white(`  ${chalk.yellow(\"npm\")} ${chalk.white(\"run build\")}`));\r\n    try {\r\n        const serve = await detectServeCommand(projectPath);\r\n        console.log(chalk.white(`  ${chalk.yellow(serve.cmd)} ${chalk.white(serve.args?.join(\" \") ?? \"\")}`));\r\n    } catch {\r\n        console.log(chalk.white(`  ${chalk.yellow(\"npm\")} ${chalk.white(\"run serve\")}`));\r\n    }\r\n\r\n    if (repoRoot) {\r\n        console.log();\r\n        console.log(chalk.green(\"Contribute back:\"));\r\n        console.log(`  ${chalk.yellow(\"cd\")} ${chalk.blue(`\"${repoRoot}\"`)} `);\r\n        console.log(chalk.white(`  ${chalk.yellow(\"git\")} ${chalk.white(\"status\")}`));\r\n        console.log(chalk.white(`  ${chalk.yellow(\"git\")} ${chalk.white(\"checkout\")} ${chalk.gray(\"-b\")} ${chalk.white(\"my-change\")}`));\r\n    }\r\n}\r\n\r\nfunction assertMode(m: string | undefined): Mode {\r\n    if (!m) return \"extract\";\r\n    if (m === \"extract\" || m === \"repo\") return m;\r\n    throw new Error(`Invalid --mode \"${m}\". Use \"extract\" or \"repo\".`);\r\n}\r\nexport { assertMode };\r\n\r\nfunction isGuid(v: string): boolean {\r\n    // Accepts RFC4122-ish GUIDs (case-insensitive)\r\n    return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(v);\r\n}\r\nexport { isGuid };\r\n\r\nasync function readJsonIfExists<T>(filePath: string): Promise<T | null> {\r\n    try {\r\n        const txt = await fs.readFile(filePath, \"utf8\");\r\n        return JSON.parse(txt) as T;\r\n    } catch {\r\n        return null;\r\n    }\r\n}\r\n\r\nasync function writeJsonPretty(filePath: string, obj: unknown): Promise<void> {\r\n    await fs.writeFile(filePath, JSON.stringify(obj, null, 2) + \"\\n\", \"utf8\");\r\n}\r\n\r\nexport async function renameSpfxProject(projectDir: string, opts: { rename?: string; newId?: string }): Promise<void> {\r\n    const pkgPath = path.join(projectDir, \"package.json\");\r\n    const pkg = await readJsonIfExists<any>(pkgPath);\r\n    const oldName: string | undefined = pkg?.name;\r\n\r\n    // package.json name\r\n    if (pkg && opts.rename) {\r\n        pkg.name = opts.rename;\r\n        await writeJsonPretty(pkgPath, pkg);\r\n    }\r\n\r\n    // .yo-rc.json: libraryName, solutionName, libraryId\r\n    const yoPath = path.join(projectDir, \".yo-rc.json\");\r\n    const yo = await readJsonIfExists<any>(yoPath);\r\n    const gen = yo?.[\"@microsoft/generator-sharepoint\"];\r\n    if (yo && gen) {\r\n        if (opts.rename) {\r\n            if (typeof gen.libraryName === \"string\") gen.libraryName = opts.rename;\r\n            if (typeof gen.solutionName === \"string\") gen.solutionName = opts.rename;\r\n        }\r\n        if (opts.newId && typeof gen.libraryId === \"string\") {\r\n            gen.libraryId = opts.newId;\r\n        }\r\n        await writeJsonPretty(yoPath, yo);\r\n    }\r\n\r\n    // config/package-solution.json: solution.name (string replace), solution.id\r\n    const psPath = path.join(projectDir, \"config\", \"package-solution.json\");\r\n    const ps = await readJsonIfExists<any>(psPath);\r\n    if (ps?.solution) {\r\n        if (opts.rename && typeof ps.solution.name === \"string\" && oldName) {\r\n            // match M365 CLI approach: replace occurrences of previous package name in the solution name\r\n            ps.solution.name = ps.solution.name.replace(new RegExp(oldName.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"), \"g\"), opts.rename);\r\n        }\r\n        if (opts.newId && typeof ps.solution.id === \"string\") {\r\n            ps.solution.id = opts.newId;\r\n        }\r\n        await writeJsonPretty(psPath, ps);\r\n    }\r\n\r\n    // config/deploy-azure-storage.json (optional): container\r\n    const dazPath = path.join(projectDir, \"config\", \"deploy-azure-storage.json\");\r\n    const daz = await readJsonIfExists<any>(dazPath);\r\n    if (daz && opts.rename && typeof daz.container === \"string\") {\r\n        daz.container = opts.rename;\r\n        await writeJsonPretty(dazPath, daz);\r\n    }\r\n\r\n    // README.md (optional): string replace oldName -> newName\r\n    const readmePath = path.join(projectDir, \"README.md\");\r\n    if (opts.rename && oldName) {\r\n        try {\r\n            const existing = await fs.readFile(readmePath, \"utf8\");\r\n            const updated = existing.replace(new RegExp(oldName.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"), \"g\"), opts.rename);\r\n            if (updated !== existing) {\r\n                await fs.writeFile(readmePath, updated, \"utf8\");\r\n            }\r\n        } catch {\r\n            // README doesn't exist in some samples; ignore\r\n        }\r\n    }\r\n}\r\n\r\nexport async function postProcessProject(projectPath: string, options: CliOptions, spinner?: ReturnType<typeof ora>): Promise<void> {\r\n    const rename = options.rename?.trim();\r\n    let newId: string | undefined;\r\n\r\n    if (options.newid) {\r\n        if (typeof options.newid === \"string\") {\r\n            const v = options.newid.trim();\r\n            if (!isGuid(v)) {\r\n                throw new Error(`--newid must be a GUID (or omit the value to auto-generate one). Received: ${v}`);\r\n            }\r\n            newId = v;\r\n        } else {\r\n            // flag was provided without a value\r\n            newId = randomUUID();\r\n        }\r\n    }\r\n\r\n    if (rename || newId) {\r\n        spinner && (spinner.text = `Updating project metadata${rename ? ` (rename â†’ ${rename})` : \"\"}${newId ? \" (new id)\" : \"\"}â€¦`);\r\n        await renameSpfxProject(projectPath, { rename, newId });\r\n    }\r\n}\r\n\r\n\r\nconst program = new Command();\r\n\r\nprogram\r\n    .name(\"spfx-sample\")\r\n    .description(\"Fetch a single sample folder from a large GitHub repo using git sparse-checkout (no full clone).\")\r\n    .version(\"0.3.0\", \"-v, --version\", \"output the current version\");\r\n\r\n// Respect NO_COLOR environment variable (https://no-color.org/) or explicit flag\r\nconst envNoColor = typeof process.env.NO_COLOR !== \"undefined\";\r\n\r\n\r\nprogram\r\n        .command(\"get\")\r\n        .argument(\"<sample>\", \"Sample folder name, e.g. react-hello-world OR samples/react-hello-world\")\r\n        .option(\"--owner <owner>\", \"GitHub org/user\", DEFAULT_OWNER)\r\n        .option(\"--repo <repo>\", \"GitHub repository name\", DEFAULT_REPO)\r\n        .option(\"--ref <ref>\", \"Git ref (branch, tag, or commit SHA)\", DEFAULT_REF)\r\n        .option(\"--dest <dest>\", \"Destination folder (default varies by --mode)\")\r\n        .option(\"--rename <newName>\", \"Rename the downloaded SPFx project (package.json/.yo-rc.json/package-solution.json/README)\")\r\n        .option(\"--newid [id]\", \"Generate or set a new SPFx solution id (GUID). If omitted value, a new GUID is generated.\")\r\n        .option(\"--mode <mode>\", 'Mode: \"extract\" (copy sample out) or \"repo\" (leave sparse repo)', \"extract\")\r\n        .option(\"--method <method>\", 'Method: \"auto\" (git if available, else api), \"git\", or \"api\"', \"auto\")\r\n        .option(\"--force\", \"Overwrite destination if it exists\", false)\r\n        .option(\"--verbose\", \"Print git output\", false)\r\n        .option(\"--no-color\", \"Disable ANSI colors\", false)\r\n\r\n    .action(async (sample: string, options: CliOptions) => {\r\n        // If NO_COLOR env var set or user passed --no-color, disable chalk output\r\n        if (envNoColor || options.noColor) {\r\n            try {\r\n                // Chalk v5: setting level to 0 disables colors\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                (chalk as any).level = 0;\r\n            } catch {\r\n                // ignore\r\n            }\r\n        }\r\n        const sampleFolder = normalizeSampleArg(sample);\r\n        const ref = options.ref || DEFAULT_REF;\r\n        const repo = options.repo || DEFAULT_REPO;\r\n        const owner = options.owner || DEFAULT_OWNER;\r\n        const verbose = !!options.verbose;\r\n\r\n        let mode: Mode;\r\n        try {\r\n            mode = assertMode(options.mode);\r\n        } catch (e) {\r\n            console.error(chalk.red((e as Error).message));\r\n            process.exitCode = 1;\r\n            return;\r\n        }\r\n\r\n        let method: Method;\r\n        try {\r\n            method = assertMethod(options.method);\r\n        } catch (e) {\r\n            console.error(chalk.red((e as Error).message));\r\n            process.exitCode = 1;\r\n            return;\r\n        }\r\n\r\n        // Default dest differs by mode:\r\n        // - extract: ./<sampleFolder>\r\n        // - repo:    ./<repo>-<sampleFolder>\r\n        const defaultDest =\r\n            mode === \"extract\" ? `./${sampleFolder}` : `./${repo}-${sampleFolder}`.replaceAll(\"/\", \"-\");\r\n\r\n        // If user provided --rename (newName) but no --dest, use the new name as destination folder.\r\n        // This makes `spfx-sample get samples/foo --rename bar` create ./bar by default.\r\n        const impliedDest = options.dest ? undefined : options.rename ? `./${options.rename}` : undefined;\r\n        const destDir = path.resolve(options.dest ?? impliedDest ?? defaultDest);\r\n\r\n        // Decide method (auto => git if available, else api)\r\n        const gitAvailable = await isGitAvailable(verbose);\r\n        const chosen: Method = method === \"auto\" ? (gitAvailable ? \"git\" : \"api\") : method;\r\n        if (verbose) console.error(`[debug] method=${method} gitAvailable=${gitAvailable} chosen=${chosen}`);\r\n\r\n        // If using git, validate git version/features\r\n        if (chosen === \"git\") {\r\n            try {\r\n                await ensureGit(verbose);\r\n            } catch (e) {\r\n                console.error(chalk.red((e as Error).message));\r\n                process.exitCode = 1;\r\n                return;\r\n            }\r\n        }\r\n\r\n        // API method can only do \"extract\" (no .git working repo)\r\n        if (chosen === \"api\" && mode === \"repo\") {\r\n            console.error(chalk.red(`--mode repo requires --method git (API method cannot create a git working repo).`));\r\n            process.exitCode = 1;\r\n            return;\r\n        }\r\n\r\n        // Handle destination\r\n            if (await pathExists(destDir)) {\r\n            if (!options.force) {\r\n                const nonEmpty = await isDirNonEmpty(destDir);\r\n                if (nonEmpty) {\r\n                    console.error(\r\n                        chalk.red(`ðŸ›‘ Destination folder is not empty: ${destDir}\\n`) +\r\n                        chalk.yellow(`Use --force to overwrite (or specify a different destination with --dest).`)\r\n                    );\r\n                    process.exitCode = 1;\r\n                    return;\r\n                }\r\n            } else {\r\n                try {\r\n                    await fs.rm(destDir, { recursive: true, force: true });\r\n                } catch (e: any) {\r\n                    if (e && (e.code === 'EBUSY' || e.code === 'EPERM')) {\r\n                        console.error(chalk.red(`ðŸ›‘ Destination folder is in use or locked: ${destDir}`));\r\n                        console.error(chalk.yellow(`Close any programs (VS Code, terminals) using the folder and try again.`));\r\n                        process.exitCode = 1;\r\n                        return;\r\n                    }\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n\r\n        const spinner = ora(`Getting sample ${sampleFolder} from ${owner}/${repo}@${ref}â€¦`).start();\r\n\r\n        // Show concise phase updates\r\n        spinner.text = `Preparing to fetch (method=${chosen})â€¦`;\r\n\r\n        // Allow aborting long-running operations (downloads, git) via Ctrl-C\r\n        const controllers: AbortController[] = [];\r\n        const topController = new AbortController();\r\n        controllers.push(topController);\r\n\r\n        const onSigint = () => {\r\n            spinner && spinner.fail(\"Aborted by user.\");\r\n            for (const c of controllers) c.abort();\r\n            // Standard unix convention: 128 + SIGINT(2) = 130\r\n            process.exit(130);\r\n        };\r\n        process.once(\"SIGINT\", onSigint);\r\n\r\n        try {\r\n            if (chosen === \"api\") {\r\n                spinner.text = `Downloading files via GitHub APIâ€¦`;\r\n                // Tokenless API method: download only that sample folder via subtree tree-walk + raw URLs\r\n                await fs.mkdir(destDir, { recursive: true });\r\n\r\n                // Render a progress bar. We don't know total until download begins, so create lazily.\r\n                let bar: ProgressBar | null = null;\r\n                let lastRendered = Date.now();\r\n\r\n                const controller = new AbortController();\r\n                controllers.push(controller);\r\n\r\n                await downloadSampleViaGitHubSubtree({\r\n                    owner,\r\n                    repo,\r\n                    ref,\r\n                    sampleFolder,\r\n                    destDir,\r\n                    concurrency: 8,\r\n                    verbose,\r\n                    signal: controller.signal,\r\n                    onProgress: (done, total, filePath) => {\r\n                        // Create bar when we know `total`\r\n                        if (!bar) {\r\n                            try {\r\n                                bar = new ProgressBar(\"[:bar] :percent :current/:total :file\", {\r\n                                    total,\r\n                                    width: 30,\r\n                                    renderThrottle: 100\r\n                                });\r\n                            } catch {\r\n                                bar = null;\r\n                            }\r\n                        }\r\n\r\n                        if (bar) {\r\n                            // tick to current count (ProgressBar expects increments)\r\n                            const delta = done - (bar.curr || 0);\r\n                            if (delta > 0) bar.tick(delta, { file: path.basename(filePath) });\r\n                        } else {\r\n                            // fallback to spinner text updates, throttle to avoid spam\r\n                            const now = Date.now();\r\n                            if (now - lastRendered > 150) {\r\n                                spinner.text = `Downloading (${done}/${total})â€¦ ${filePath}`;\r\n                                lastRendered = now;\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n\r\n                spinner.text = `Post-processing project filesâ€¦`;\r\n                await postProcessProject(destDir, options, spinner);\r\n                await finalizeExtraction({\r\n                    spinner,\r\n                    successMessage: `Done! Downloaded ${chalk.cyan(`samples/${sampleFolder}`)} into ${chalk.green(destDir)}`,\r\n                    projectPath: destDir\r\n                });\r\n                return;\r\n            }\r\n\r\n            // chosen === \"git\"\r\n            if (mode === \"extract\") {\r\n                spinner.text = `Performing sparse git extractâ€¦`;\r\n                await fetchSampleViaSparseGitExtract({\r\n                    owner,\r\n                    repo,\r\n                    ref,\r\n                    sampleFolder,\r\n                    destDir,\r\n                    verbose,\r\n                    spinner,\r\n                    signal: topController.signal\r\n                });\r\n\r\n                spinner.text = `Post-processing project filesâ€¦`;\r\n                await postProcessProject(destDir, options, spinner);\r\n                await finalizeExtraction({\r\n                    spinner,\r\n                    successMessage: `Done! Extracted ${chalk.cyan(`samples/${sampleFolder}`)} into ${chalk.green(destDir)}`,\r\n                    projectPath: destDir\r\n                });\r\n\r\n            } else {\r\n                // repo mode: sparse clone directly into destDir and keep .git there\r\n                await fs.mkdir(destDir, { recursive: true });\r\n\r\n                spinner.text = `Performing sparse git clone (repo mode)â€¦`;\r\n                await sparseCloneInto({\r\n                    owner,\r\n                    repo,\r\n                    ref,\r\n                    sampleFolder,\r\n                    repoDir: destDir,\r\n                    verbose,\r\n                    spinner,\r\n                    signal: topController.signal\r\n                });\r\n\r\n                const samplePath = path.join(destDir, \"samples\", sampleFolder);\r\n\r\n                await postProcessProject(samplePath, options, spinner);\r\n                await finalizeExtraction({\r\n                    spinner,\r\n                    successMessage: `Done! Sparse repo ready at ${chalk.green(destDir)} (sample at ${chalk.cyan(samplePath)})`,\r\n                    projectPath: samplePath,\r\n                    repoRoot: destDir\r\n                });\r\n            }\r\n        } catch (err) {\r\n            spinner.fail((err as Error).message);\r\n            process.exitCode = 1;\r\n        }\r\n    });\r\n\r\n/**\r\n * Testable handler for the `get` command. Allows injecting dependencies for unit testing.\r\n */\r\nexport async function getCommandHandler(sample: string, options: CliOptions, deps?: {\r\n    download?: typeof downloadSampleViaGitHubSubtree;\r\n    fetchSparse?: typeof fetchSampleViaSparseGitExtract;\r\n    sparseClone?: typeof sparseCloneInto;\r\n    postProcess?: typeof postProcessProject;\r\n    finalize?: typeof finalizeExtraction;\r\n    isGitAvailable?: typeof isGitAvailable;\r\n    ensureGit?: typeof ensureGit;\r\n}) {\r\n    const sampleFolder = normalizeSampleArg(sample);\r\n    const ref = options.ref || DEFAULT_REF;\r\n    const repo = options.repo || DEFAULT_REPO;\r\n    const owner = options.owner || DEFAULT_OWNER;\r\n    const verbose = !!options.verbose;\r\n\r\n    const download = deps?.download ?? downloadSampleViaGitHubSubtree;\r\n    const fetchSparse = deps?.fetchSparse ?? fetchSampleViaSparseGitExtract;\r\n    const sparseClone = deps?.sparseClone ?? sparseCloneInto;\r\n    const postProcess = deps?.postProcess ?? postProcessProject;\r\n    const finalize = deps?.finalize ?? finalizeExtraction;\r\n    const gitAvailableFn = deps?.isGitAvailable ?? isGitAvailable;\r\n    const ensureGitFn = deps?.ensureGit ?? ensureGit;\r\n\r\n    let mode: Mode;\r\n    try {\r\n        mode = assertMode(options.mode);\r\n    } catch (e) {\r\n        throw e;\r\n    }\r\n\r\n    let method: Method;\r\n    try {\r\n        method = assertMethod(options.method);\r\n    } catch (e) {\r\n        throw e;\r\n    }\r\n\r\n    const defaultDest = mode === \"extract\" ? `./${sampleFolder}` : `./${repo}-${sampleFolder}`.replaceAll(\"/\", \"-\");\r\n\r\n    // When running programmatically, if --dest isn't provided but --rename/newName is,\r\n    // treat the new name as the destination folder so callers get the same behavior as the CLI.\r\n    const impliedDest = options.dest ? undefined : options.rename ? `./${options.rename}` : undefined;\r\n    const destDir = path.resolve(options.dest ?? impliedDest ?? defaultDest);\r\n\r\n    const gitAvailable = await gitAvailableFn(verbose);\r\n    const chosen: Method = method === \"auto\" ? (gitAvailable ? \"git\" : \"api\") : method;\r\n\r\n    if (chosen === \"git\") {\r\n        await ensureGitFn(verbose);\r\n    }\r\n\r\n    if (chosen === \"api\" && mode === \"repo\") {\r\n        throw new Error(`--mode repo requires --method git (API method cannot create a git working repo).`);\r\n    }\r\n\r\n    if (await pathExists(destDir)) {\r\n        if (!options.force) {\r\n            const nonEmpty = await isDirNonEmpty(destDir);\r\n            if (nonEmpty) throw new Error(`Destination exists and is not empty: ${destDir}`);\r\n        } else {\r\n            try {\r\n                await fs.rm(destDir, { recursive: true, force: true });\r\n            } catch (e: any) {\r\n                if (e && (e.code === 'EBUSY' || e.code === 'EPERM')) {\r\n                    throw new Error(`Destination folder is in use or locked: ${destDir}`);\r\n                }\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (chosen === \"api\") {\r\n        await fs.mkdir(destDir, { recursive: true });\r\n        await download({ owner, repo, ref, sampleFolder, destDir, concurrency: 8, verbose, signal: undefined, onProgress: undefined });\r\n        await postProcess(destDir, options, undefined);\r\n        await finalize({ spinner: undefined, successMessage: `Done`, projectPath: destDir });\r\n        return;\r\n    }\r\n\r\n    if (chosen === \"git\") {\r\n        if (mode === \"extract\") {\r\n            await fetchSparse({ owner, repo, ref, sampleFolder, destDir, verbose, spinner: undefined, signal: undefined });\r\n            await postProcess(destDir, options, undefined);\r\n            await finalize({ spinner: undefined, successMessage: `Done`, projectPath: destDir });\r\n            return;\r\n        } else {\r\n            await fs.mkdir(destDir, { recursive: true });\r\n            await sparseClone({ owner, repo, ref, sampleFolder, repoDir: destDir, verbose, spinner: undefined, signal: undefined });\r\n            const samplePath = path.join(destDir, \"samples\", sampleFolder);\r\n            await postProcess(samplePath, options, undefined);\r\n            await finalize({ spinner: undefined, successMessage: `Done`, projectPath: samplePath, repoRoot: destDir });\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\nprogram\r\n    .command(\"rename\")\r\n    .argument(\"<path>\", \"Path to previously downloaded sample folder (project root)\")\r\n    .option(\"--newname <newName>\", \"Rename the SPFx project (package.json/.yo-rc.json/package-solution.json/README)\")\r\n    .option(\"--newid [id]\", \"Generate or set a new SPFx solution id (GUID). If omitted value, a new GUID is generated.\")\r\n    .option(\"--verbose\", \"Print debug output\", false)\r\n    .option(\"--no-color\", \"Disable ANSI colors\", false)\r\n    .action(async (p: string, options: { newname?: string; newid?: string | boolean; verbose?: boolean; noColor?: boolean }) => {\r\n        if (envNoColor || options.noColor) {\r\n            try { (chalk as any).level = 0; } catch {}\r\n        }\r\n\r\n        const projectPath = path.resolve(p);\r\n\r\n        // Validate path exists\r\n        if (!(await pathExists(projectPath))) {\r\n            console.error(chalk.red(`Path not found: ${projectPath}`));\r\n            process.exitCode = 1;\r\n            return;\r\n        }\r\n\r\n        const opts: CliOptions = { rename: options.newname, newid: typeof options.newid === 'string' ? options.newid : options.newid ? true : undefined } as any;\r\n\r\n        const spinner = ora(`Renaming project at ${projectPath}â€¦`).start();\r\n        try {\r\n            await postProcessProject(projectPath, opts, spinner);\r\n            spinner.succeed(`Updated project at ${projectPath}`);\r\n        } catch (err) {\r\n            spinner.fail((err as Error).message);\r\n            process.exitCode = 1;\r\n        }\r\n    });\r\n\r\nif (process.env.NODE_ENV !== \"test\") {\r\n    program.parse(process.argv);\r\n}\r\n","import path from \"node:path\";\r\nimport fs from \"node:fs/promises\";\r\n\r\ntype TreeItem = { path: string; type: \"blob\" | \"tree\"; sha: string };\r\ntype TreeResponse = { tree: TreeItem[]; truncated?: boolean; message?: string };\r\n\r\n/**\r\n * Options for downloading a subtree (a specific folder and its contents) from a GitHub repository.\r\n *\r\n * Provides the repository identity, the Git reference to fetch from, the path of the folder inside\r\n * the repository to download, and where to write the files locally. Also allows tuning concurrency\r\n * and reporting progress.\r\n *\r\n * @property owner - The GitHub repository owner (for example: \"pnp\").\r\n * @property repo - The repository name (for example: \"sp-dev-fx-webparts\").\r\n * @property ref - The Git reference to download from; can be a branch name, tag, or commit SHA.\r\n * @property sampleFolder - The path to the folder inside the repository that should be downloaded\r\n *                          (for example: \"react-hello-world\").\r\n * @property destDir - Local destination directory where the downloaded files will be written.\r\n * @property concurrency - Optional maximum number of concurrent network/file operations. Defaults to 8.\r\n * @property onProgress - Optional callback invoked to report progress. Called with (done, total, filePath)\r\n *                        where `done` is the number of files already processed, `total` is the total\r\n *                        number of files to process, and `filePath` is the path of the file most recently processed.\r\n *\r\n * @example\r\n * // Example usage:\r\n * // {\r\n * //   owner: \"pnp\",\r\n * //   repo: \"sp-dev-fx-webparts\",\r\n * //   ref: \"v1.0.0\",\r\n * //   sampleFolder: \"react-hello-world\",\r\n * //   destDir: \"./samples/react-hello-world\",\r\n * //   concurrency: 8,\r\n * //   onProgress: (done, total, filePath) => { console.log(`${done}/${total}: ${filePath}`); }\r\n * // }\r\n *\r\n */\r\nexport type DownloadSubtreeOptions = {\r\n    owner: string;          // e.g. \"pnp\"   \r\n    repo: string;           // e.g. \"sp-dev-fx-webparts\"\r\n    ref: string;            // branch/tag/sha\r\n    sampleFolder: string;   // e.g. \"react-hello-world\"\r\n    destDir: string;        // where to write files\r\n    concurrency?: number;   // default 8\r\n    onProgress?: (done: number, total: number, filePath: string) => void;\r\n    signal?: AbortSignal;\r\n    verbose?: boolean;\r\n};\r\n\r\n\r\n/**\r\n * Creates a simple counting semaphore to limit the number of concurrently running asynchronous tasks.\r\n *\r\n * The returned function accepts an async function (a function that returns a Promise)\r\n * and schedules its execution. If the number of currently running tasks is below the\r\n * specified maximum, the provided function is invoked immediately; otherwise it is\r\n * enqueued and will be invoked in FIFO order when a slot becomes available.\r\n *\r\n * @template T - The resolved type of the Promise returned by the scheduled function.\r\n * @param max - Maximum number of tasks allowed to run concurrently. Should be a positive integer (>= 1).\r\n *              If a non-positive value is supplied, tasks will be enqueued and none will start,\r\n *              so pass a positive value to avoid deadlock.\r\n * @returns A function that takes an async function `fn: () => Promise<T>` and returns a `Promise<T>`\r\n *          that resolves or rejects with the result of `fn`. The semaphore ensures that at most\r\n *          `max` invocations of `fn` are running at any given time. When a running task settles\r\n *          (either fulfills or rejects), the semaphore decrements its internal counter and starts\r\n *          the next queued task (if any).\r\n *\r\n * @remarks\r\n * - Errors thrown or rejections from the provided function are propagated to the caller of the\r\n *   returned scheduling function; the semaphore still releases the slot (so subsequent queued tasks run).\r\n * - Queue ordering is FIFO: tasks are started in the order they were scheduled when slots free up.\r\n *\r\n * @example\r\n * // Create a semaphore allowing 3 concurrent tasks\r\n * const sem = createSemaphore(3);\r\n *\r\n * // Schedule work\r\n * const result = await sem(async () => {\r\n *   // perform async work here\r\n *   return await fetchData();\r\n * });\r\n */\r\nfunction createSemaphore(max: number) {\r\n    let running = 0;\r\n    const queue: Array<() => void> = [];\r\n    const next = () => {\r\n        running--;\r\n        const fn = queue.shift();\r\n        if (fn) fn();\r\n    };\r\n    return async <T>(fn: () => Promise<T>): Promise<T> =>\r\n        new Promise<T>((resolve, reject) => {\r\n            const run = async () => {\r\n                running++;\r\n                try { resolve(await fn()); }\r\n                catch (e) { reject(e); }\r\n                finally { next(); }\r\n            };\r\n            if (running < max) run();\r\n            else queue.push(run);\r\n        });\r\n}\r\n\r\n/**\r\n * Fetches JSON from the given URL and returns it typed as T.\r\n *\r\n * @template T - The expected shape of the parsed JSON response.\r\n * @param url - The URL to fetch.\r\n * @returns A promise that resolves to the parsed JSON cast to T.\r\n * @throws {Error} If the response is not ok, including a friendly message when the\r\n *  GitHub anonymous rate limit is hit, or if JSON parsing fails. Network errors\r\n *  from the Fetch API will also propagate as rejected promises.\r\n *\r\n * @remarks\r\n * - Adds a \"User-Agent\": \"@pnp/spfx-sample\" header to the request.\r\n * - On non-ok responses, prefers the API-provided error message (data.message)\r\n *   when available; otherwise includes the HTTP status and statusText.\r\n * - Detects GitHub anonymous rate limiting: when status is 403 and the\r\n *   \"X-RateLimit-Remaining\" header equals \"0\", throws a specific rate-limit error\r\n *   advising to retry later or use the git method.\r\n * - Uses response.json() to parse the body; callers should expect parsing errors\r\n *   if the response is not valid JSON.\r\n */\r\nasync function fetchJson<T>(url: string, signal?: AbortSignal, verbose?: boolean): Promise<T> {\r\n    verbose && console.error(`[debug] GET ${url}`);\r\n    const res = await fetch(url, { headers: { \"User-Agent\": \"@pnp/spfx-sample\" }, signal });\r\n    const data = (await res.json()) as any;\r\n\r\n    if (!res.ok) {\r\n        // friendly rate-limit message\r\n        if (res.status === 403 && res.headers.get(\"X-RateLimit-Remaining\") === \"0\") {\r\n            throw new Error(\r\n                \"GitHub anonymous rate limit hit (60/hr per IP). Try again later, or install/use the git method.\"\r\n            );\r\n        }\r\n        throw new Error(`GitHub API error: ${data?.message ?? `${res.status} ${res.statusText}`}`);\r\n    }\r\n\r\n    return data as T;\r\n}\r\n\r\n/**\r\n * Fetches a Git tree object from the GitHub REST API for the specified repository.\r\n *\r\n * The function constructs a GET request to:\r\n *   https://api.github.com/repos/{owner}/{repo}/git/trees/{treeish}\r\n * and, if `recursive` is true, appends the `?recursive=1` query to retrieve the entire\r\n * subtree (all nested trees and blobs).\r\n *\r\n * @param owner - The owner (user or organization) of the GitHub repository.\r\n * @param repo - The name of the GitHub repository.\r\n * @param treeish - A tree-ish reference that identifies the tree to fetch (branch name, tag, or commit SHA).\r\n *                   This value is URL-encoded before being placed into the request path.\r\n * @param recursive - When true, requests the tree recursively (including nested trees/blobs). Defaults to false.\r\n *\r\n * @returns A promise that resolves to the parsed TreeResponse returned by the GitHub API.\r\n *\r\n * @throws Will reject if the network request fails or if the API returns an error status (see fetchJson behavior).\r\n *\r\n * @remarks\r\n * - The request is subject to GitHub API rate limits and may require authentication depending on repository visibility and rate usage.\r\n * - The exact shape of TreeResponse is defined elsewhere in the codebase and mirrors the GitHub API's tree response structure.\r\n */\r\nasync function fetchTree(owner: string, repo: string, treeish: string, recursive = false, signal?: AbortSignal, verbose?: boolean): Promise<TreeResponse> {\r\n    const url = `https://api.github.com/repos/${owner}/${repo}/git/trees/${encodeURIComponent(treeish)}${recursive ? \"?recursive=1\" : \"\"}`;\r\n    return fetchJson<TreeResponse>(url, signal, verbose);\r\n}\r\n\r\n/**\r\n * Ensures that the directory containing the given file path exists by creating it (and any necessary parent directories) if absent.\r\n *\r\n * @param filePath - The full path to the file whose containing directory should be created.\r\n * @returns A promise that resolves when the directory has been created or already exists.\r\n * @remarks\r\n * This function uses a recursive directory creation strategy (fs.mkdir with { recursive: true }) and does not create the file itself.\r\n * If the operation fails, the returned promise will reject with the underlying filesystem error.\r\n *\r\n * @example\r\n * // Ensure the directory for \"/tmp/data/output.txt\" exists before writing the file\r\n * await ensureDirForFile(\"/tmp/data/output.txt\");\r\n */\r\nasync function ensureDirForFile(filePath: string): Promise<void> {\r\n    await fs.mkdir(path.dirname(filePath), { recursive: true });\r\n}\r\n\r\n/**\r\n * Downloads all files from a sample subfolder in a GitHub repository using the GitHub tree API\r\n * (to enumerate files) and raw.githubusercontent.com (to fetch file contents).\r\n *\r\n * The function expects the repository to have a top-level \"samples\" folder and will locate the\r\n * specific sample by name (samples/<sampleFolder>). It enumerates the sample subtree recursively,\r\n * filters for blob entries (files), and downloads each file in parallel (bounded by a semaphore).\r\n * Directory structure from the sample is recreated under the provided destination directory.\r\n *\r\n * @remarks\r\n * - Uses a helper `fetchTree(owner, repo, refOrSha, recursive)` to list git trees. If that helper\r\n *   returns an error object (has a `message`), the function will throw with that message.\r\n * - If the recursive tree listing is truncated, this function will throw and recommend using the\r\n *   alternate git-based method.\r\n * - Files are fetched from raw.githubusercontent.com using the provided ref (URL-encoded) and the\r\n *   full path `samples/<sampleFolder>/<relativePath>`.\r\n * - Destination directories are created as needed before writing files.\r\n * - Progress is reported via an optional callback after each successfully written file.\r\n *\r\n * @param opts - Options describing which repository/sample to download and how.\r\n * @param opts.owner - GitHub repository owner (user or organization).\r\n * @param opts.repo - GitHub repository name.\r\n * @param opts.ref - Git reference to use (branch name, tag, or commit SHA).\r\n * @param opts.sampleFolder - Name of the sample folder inside the repository's top-level \"samples\" directory.\r\n * @param opts.destDir - Local filesystem directory to write the downloaded files into. The sample's\r\n *                       relative paths are preserved under this directory.\r\n * @param opts.concurrency - Optional. Maximum number of concurrent HTTP downloads. Defaults to 8.\r\n * @param opts.onProgress - Optional. Callback invoked after each file is written with signature\r\n *                          (done: number, total: number, filePath: string) where `filePath` is the\r\n *                          repository path (samples/<sampleFolder>/<relativePath>) of the file just downloaded.\r\n *\r\n * @async\r\n * @returns A Promise that resolves when all files have been downloaded and written to disk.\r\n *\r\n * @throws Error if:\r\n * - the repository root or expected \"samples\" tree cannot be found,\r\n * - the requested sample folder under \"samples\" does not exist,\r\n * - the recursive tree listing is truncated,\r\n * - no files (blobs) are found in the sample folder,\r\n * - any HTTP request for a file returns a non-OK response,\r\n * - file system operations (directory creation or file writes) fail,\r\n * - or if the underlying `fetchTree` helper returns an error message.\r\n */\r\nexport async function downloadSampleViaGitHubSubtree(opts: DownloadSubtreeOptions): Promise<void> {\r\n    const { owner, repo, ref, sampleFolder, destDir } = opts;\r\n    const concurrency = opts.concurrency ?? 8;\r\n    const signal = opts.signal;\r\n\r\n    if (signal?.aborted) throw new Error(\"Download aborted\");\r\n\r\n    // root tree\r\n    const root = await fetchTree(owner, repo, ref, false, opts.signal, opts.verbose);\r\n    if (root.message) throw new Error(root.message);\r\n\r\n    const samplesTree = root.tree.find(t => t.type === \"tree\" && t.path === \"samples\");\r\n    if (!samplesTree) throw new Error(`Could not find /samples at ${owner}/${repo}@${ref}`);\r\n\r\n    // /samples tree\r\n    const samples = await fetchTree(owner, repo, samplesTree.sha, false, opts.signal, opts.verbose);\r\n    const sampleTree = samples.tree.find(t => t.type === \"tree\" && t.path === sampleFolder);\r\n    if (!sampleTree) throw new Error(`Sample folder not found: samples/${sampleFolder} at ${ref}`);\r\n\r\n    // sample subtree (recursive)\r\n    const sample = await fetchTree(owner, repo, sampleTree.sha, true, opts.signal, opts.verbose);\r\n    if (sample.truncated) {\r\n        // extremely unlikely for a single sample, but handle anyway\r\n        throw new Error(`Tree listing truncated for samples/${sampleFolder}. Use the git method.`);\r\n    }\r\n\r\n    const blobs = sample.tree.filter(t => t.type === \"blob\");\r\n    if (blobs.length === 0) throw new Error(`No files found in samples/${sampleFolder}`);\r\n\r\n    await fs.mkdir(destDir, { recursive: true });\r\n\r\n    const sem = createSemaphore(concurrency);\r\n    let done = 0;\r\n\r\n    await Promise.all(\r\n        blobs.map(b =>\r\n            sem(async () => {\r\n                const rel = b.path; // path relative to samples/<sampleFolder>\r\n                const fullRepoPath = `samples/${sampleFolder}/${rel}`;\r\n\r\n                if (opts.signal?.aborted) throw new Error(\"Download aborted\");\r\n\r\n                const rawUrl = `https://raw.githubusercontent.com/${owner}/${repo}/${encodeURIComponent(ref)}/${fullRepoPath}`;\r\n                opts.verbose && console.error(`[debug] GET ${rawUrl}`);\r\n                const res = await fetch(rawUrl, { signal: opts.signal });\r\n                if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText} for ${fullRepoPath}`);\r\n\r\n                const bytes = new Uint8Array(await res.arrayBuffer());\r\n                const outPath = path.join(destDir, rel);\r\n\r\n                await ensureDirForFile(outPath);\r\n                await fs.writeFile(outPath, bytes);\r\n\r\n                done++;\r\n                opts.onProgress?.(done, blobs.length, fullRepoPath);\r\n            })\r\n        )\r\n    );\r\n}\r\n","import { access } from \"node:fs/promises\";\r\nimport { spawnSync } from \"node:child_process\";\r\nimport os from \"node:os\";\r\nimport path from \"node:path\";\r\n\r\nasync function exists(p: string): Promise<boolean> {\r\n  try {\r\n    await access(p);\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction which(cmd: string): string | null {\r\n  const runner = process.platform === \"win32\" ? \"where\" : \"command\";\r\n  const args = process.platform === \"win32\" ? [cmd] : [\"-v\", cmd];\r\n  try {\r\n    const res = spawnSync(runner, args, { encoding: \"utf8\", shell: false });\r\n    if (res.status === 0) {\r\n      const out = (res.stdout || res.stderr || \"\").split(/\\r?\\n/).find(Boolean);\r\n      return out ? out.trim() : null;\r\n    }\r\n  } catch {\r\n    // ignore\r\n  }\r\n  return null;\r\n}\r\n\r\nexport type VersionManagers = {\r\n  nvmPosix: boolean;\r\n  nvmPosixDir?: string | null;\r\n  nvmWindows: boolean;\r\n  nvmWindowsPath?: string | null;\r\n  nvs: boolean;\r\n  nvsPath?: string | null;\r\n};\r\n\r\n/**\r\n * Detect whether common Node version managers are installed on the host.\r\n * - `nvm` (POSIX) is typically detected via NVM_DIR or ~/.nvm\r\n * - `nvm-windows` is detected via NVM_HOME/NVM_SYMLINK or nvm.exe on PATH\r\n * - `nvs` is detected via NVS_HOME or `nvs` on PATH\r\n */\r\nexport async function detectVersionManagers(): Promise<VersionManagers> {\r\n  const found: VersionManagers = { nvmPosix: false, nvmPosixDir: null, nvmWindows: false, nvmWindowsPath: null, nvs: false, nvsPath: null };\r\n\r\n  // POSIX nvm\r\n  if (process.env.NVM_DIR) {\r\n    found.nvmPosix = true;\r\n    found.nvmPosixDir = process.env.NVM_DIR;\r\n  } else {\r\n    const maybe = path.join(os.homedir(), \".nvm\");\r\n    if (await exists(maybe)) {\r\n      found.nvmPosix = true;\r\n      found.nvmPosixDir = maybe;\r\n    }\r\n  }\r\n\r\n  // nvm-windows\r\n  if (process.env.NVM_HOME || process.env.NVM_SYMLINK) {\r\n    found.nvmWindows = true;\r\n    found.nvmWindowsPath = process.env.NVM_HOME ?? process.env.NVM_SYMLINK ?? null;\r\n  } else {\r\n    const w = which(process.platform === \"win32\" ? \"nvm.exe\" : \"nvm\");\r\n    if (w) {\r\n      // on Windows this will be nvm.exe; on POSIX seeing `nvm` is ambiguous (often a shell function)\r\n      if (process.platform === \"win32\" || w.toLowerCase().endsWith(\"nvm.exe\")) {\r\n        found.nvmWindows = true;\r\n        found.nvmWindowsPath = w;\r\n      }\r\n    }\r\n  }\r\n\r\n  // nvs\r\n  if (process.env.NVS_HOME) {\r\n    found.nvs = true;\r\n    found.nvsPath = process.env.NVS_HOME;\r\n  } else {\r\n    const n = which(\"nvs\");\r\n    if (n) {\r\n      found.nvs = true;\r\n      found.nvsPath = n;\r\n    }\r\n  }\r\n\r\n  return found;\r\n}\r\n\r\nexport default detectVersionManagers;\r\n","import { readFile } from \"node:fs/promises\";\r\nimport path from \"node:path\";\r\n\r\nexport type ServeCommand = { cmd: string; args?: string[] };\r\n\r\n/**\r\n * Inspect a project's package.json and files to recommend a serve command.\r\n * - If package.json scripts include \"start\" or \"serve\", prefer those.\r\n * - If project uses \"heft\" (devDependency or script), recommend \"npm run start\" (heft convention).\r\n * - If Gulpfile exists or gulp present in devDependencies, recommend \"gulp serve\".\r\n */\r\nexport async function detectServeCommand(projectDir: string): Promise<ServeCommand> {\r\n  const pkgPath = path.join(projectDir, \"package.json\");\r\n  try {\r\n    const txt = await readFile(pkgPath, \"utf8\");\r\n    const pkg = JSON.parse(txt);\r\n\r\n    // If explicit scripts exist, prefer them\r\n    if (pkg.scripts) {\r\n      if (pkg.scripts.start) return { cmd: \"npm\", args: [\"run\", \"start\"] };\r\n      if (pkg.scripts.serve) return { cmd: \"npm\", args: [\"run\", \"serve\"] };\r\n    }\r\n\r\n    // Check devDependencies / dependencies for heft or gulp\r\n    const deps = { ...(pkg.dependencies || {}), ...(pkg.devDependencies || {}) };\r\n    if (deps.heft || deps[\"@microsoft/heft\"]) {\r\n      // Heft-based projects typically use `npm start` (heft start)\r\n      return { cmd: \"npm\", args: [\"run\", \"start\"] };\r\n    }\r\n    if (deps.gulp || deps[\"gulp-cli\"]) {\r\n      return { cmd: \"gulp\", args: [\"serve\"] };\r\n    }\r\n  } catch {\r\n    // ignore file read/parse errors\r\n  }\r\n\r\n  // Fallback: check for gulpfile\r\n  try {\r\n    const gf = path.join(projectDir, \"gulpfile.js\");\r\n    // only check existence synchronously via require('fs').existsSync to avoid extra async imports\r\n    // but to keep API minimal, use try/catch with readFile\r\n    await readFile(gf, \"utf8\");\r\n    return { cmd: \"gulp\", args: [\"serve\"] };\r\n  } catch {\r\n    // noop\r\n  }\r\n\r\n  // Default fallback\r\n  return { cmd: \"npm\", args: [\"run\", \"serve\"] };\r\n}\r\n\r\nexport default detectServeCommand;\r\n"],"mappings":"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","names":["path","os","fs","run","path","path","fs","fs","path","os","parseSemverLoose","pickHighest","semKey","path","path","os","fs","fs","path"]}